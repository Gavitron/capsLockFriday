#include <Arduino.h>
#include <ss_oled.h>
#include <HID-Project.h>

/// Setup for the OLED library
//--------------
#define USE_BACKBUFFER
static uint8_t ucBackBuffer[1024];

// Use -1 for the Wire library default pins
// or specify the pin numbers to use with the Wire library or bit banging on any GPIO pins
// These are the pin numbers for the M5Stack Atom default I2C
//#define SDA_PIN 2
//#define SCL_PIN 3
// Set this to -1 to disable or the GPIO pin number connected to the reset
// line of your display if it requires an external reset
#define RESET_PIN -1
// let ss_oled figure out the display address
#define OLED_ADDR 0x3C
// don't rotate the display
#define FLIP180 0
// don't invert the display
#define INVERT 0
// Bit-Bang the I2C bus
#define USE_HW_I2C 1

// Change these if you're using a different OLED display
#define MY_OLED OLED_128x32
#define OLED_WIDTH 128
#define OLED_HEIGHT 32

SSOLED ssoled;

// ----------

const int pinSDA = 2;
const int pinSCL = 3;
const int pinLed = 4;
const int pinButton = 9;


/// =============================

void setup() {
  pinMode(pinLed, OUTPUT);
  pinMode(pinButton, INPUT_PULLUP);

  // Sends a clean report to the host. This is important on any Arduino type.
  BootKeyboard.begin();

  int rc;
  rc = oledInit(&ssoled, MY_OLED, OLED_ADDR, FLIP180, INVERT, USE_HW_I2C, pinSDA, pinSCL, RESET_PIN, 400000L); // use standard I2C bus at 400Khz
  if (rc != OLED_NOT_FOUND) {
    char *msgs[] = {(char *)"SSD1306 @ 0x3C", (char *)"SSD1306 @ 0x3D",(char *)"SH1106 @ 0x3C",(char *)"SH1106 @ 0x3D"};
    oledFill(&ssoled, 0, 1);
    oledWriteString(&ssoled, 0,0,0,msgs[rc], FONT_NORMAL, 0, 1);
    oledSetBackBuffer(&ssoled, ucBackBuffer);
   delay(500);

    oledFill(&ssoled, 0x0, 1);
    oledWriteString(&ssoled, 0,16,0,(char *)"ss_oled Demo", FONT_NORMAL, 0, 1);
    oledWriteString(&ssoled, 0,0,1,(char *)"Written by Larry Bank", FONT_SMALL, 1, 1);
    oledWriteString(&ssoled, 0,16,2,(char *)"ss_oled Demo", FONT_NORMAL, 0, 1);
    oledWriteString(&ssoled, 0,0,3,(char *)"Written by Larry Bank", FONT_SMALL, 1, 1);
    delay(2000);
  }

  // Flash LED
  digitalWrite(pinLed, LOW);
  for (int i = 0; i < 5; i++) {
    delay(60);
    digitalWrite(pinLed, HIGH);
    delay(60);
    digitalWrite(pinLed, LOW);
  }

}

/// =============================

void loop() {
  // Update Led equal to the caps lock state.
  // Keep in mind that on a 16u2 and Arduino Micro HIGH and LOW for TX/RX Leds are inverted.
  if (BootKeyboard.getLeds() & LED_CAPS_LOCK) {
    digitalWrite(pinLed, HIGH);
    oledWriteString(&ssoled, 0,0,0,(char *)"szTemp", FONT_NORMAL, 0, 1);
    oledWriteString(&ssoled, 0,0,1,(char *)"With backbuffer", FONT_SMALL,0,1);
    oledWriteString(&ssoled, 0,0,2,(char *)"szTemp", FONT_NORMAL, 0, 1);
    oledWriteString(&ssoled, 0,0,3,(char *)"With backbuffer", FONT_SMALL,0,1);
    delay(50);
  } else {
    digitalWrite(pinLed, LOW);
    oledFill(&ssoled, 0x0, 1);
  }

  // Trigger caps lock manually via button
  if (!digitalRead(pinButton)) {
    BootKeyboard.write(KEY_CAPS_LOCK);

    // Simple debounce
    digitalWrite(pinLed, HIGH);
    delay(300);
    digitalWrite(pinLed, LOW);
  }
}
